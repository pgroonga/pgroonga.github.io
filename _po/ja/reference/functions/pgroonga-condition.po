msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2023-08-13 09:55+0900\n"

msgid ""
"---\n"
"title: pgroonga_condition function\n"
"upper_level: ../\n"
"---"
msgstr ""
"---\n"
"title: pgroonga_condition 関数\n"
"upper_level: ../\n"
"---"

msgid "# `pgroonga_condition()` function"
msgstr "# `pgroonga_condition()` 関数"

msgid "## Summary"
msgstr "## 概要"

msgid ""
"`pgroonga_condition()` function return `pgroonga_condition` type value.\n"
"The function and the type have same name, but they are two different "
"things.\n"
"`pgroonga_condition` type represent complicated conditional expressions, "
"such as `pgroonga_full_text_search_condition` type and "
"`pgroonga_full_text_search_condition_with_scorers` type."
msgstr ""
"`pgroonga_condition()`関数は`pgroonga_condition`型の値を返します。\n"
"関数名と型名が同じですが別物です。\n"
"`pgroonga_condition`型は`pgroonga_full_text_search_condition`型や"
"`pgroonga_full_text_search_condition_with_scorers`型のように複雑な条件式を表"
"現します。"

msgid ""
"`pgroonga_condition()` function is a useful function to make the "
"`pgroonga_condition` type value.\n"
"It allows to make the `pgroonga_condition` type value by designating the "
"specific attribute value."
msgstr ""
"`pgroonga_condition()`関数は`pgroonga_condition`型の値を作るための便利関数で"
"す。\n"
"特定の属性値のみを指定して`pgroonga_condition`型の値を作れます。"

msgid ""
"There were not this kind of useful functions for "
"`pgroonga_full_text_search_condition` type and "
"`pgroonga_full_text_search_condition_with_scorers` type, so designating all "
"attribute values was necessary to make the value."
msgstr ""
"`pgroonga_full_text_search_condition`型や"
"`pgroonga_full_text_search_condition_with_scorers`型では、このような便利関数"
"がなかったため必ず全ての属性値を指定して値を作る必要がありました。"

msgid ""
"Therefore, you need to designate `NULL` for disused attribute value as "
"follows when `pgroonga_full_text_search_condition` type and "
"`pgroonga_full_text_search_condition_with_scorers` type are used to avoid "
"making all the values."
msgstr ""
"したがって、不要な属性値があっても、`pgroonga_full_text_search_condition`型や"
"`pgroonga_full_text_search_condition_with_scorers`型では、次のように不要な属"
"性値には`NULL`を指定する必要がありました。"

msgid ""
"```\n"
"title &@~ ('keyword', NULL, 'index_name')::"
"pgroonga_full_text_search_condition\n"
"title &@~ ('keyword', ARRAY[1,1,1,5,0], NULL, 'index_name')::"
"pgroonga_full_text_search_condition_with_scorers\n"
"```"
msgstr ""

msgid ""
"It was not possible for existing value creation methods to make new "
"attribute value while keeping backward compatibility.\n"
"Thus, it was necessary to add a new type every time a new attribute value is "
"added, such as `pgroonga_full_text_search_condition_with_XXX` type.\n"
"For example, `pgroogna_full_text_search_condition_with_scorers` type was "
"added because of the added new attribution."
msgstr ""
"型を指定して直接値を作る従来の方法では後方互換性を維持したまま新しい属性を作"
"ることができませんでした。\n"
"そのため、新しい属性を追加するたびに"
"`pgroonga_full_text_search_condition_with_XXX`というような新しい型を追加する"
"必要がありました。\n"
"たとえば、`pgroogna_full_text_search_condition_with_scorers`型はそのために追"
"加された型です。"

msgid ""
"The difference between `pgroonga_full_text_search_condition` type and "
"`pgroonga_full_text_search_condition_with_scorers` type is whether `scorers` "
"exist or not. If `scorers` is added to `pgroonga_full_text_search_condition` "
"type, every users are required to insert new 'NULL' to make "
"`pgroonga_full_text_search_condition` type regardless of `scorers` usage."
msgstr ""
"`pgroonga_full_text_search_condition`型と"
"`pgroonga_full_text_search_condition_with_scorers`型の違いは`scorers`が存在す"
"るかどうかですが、`pgroonga_full_text_search_condition`型に`scorers`を追加し"
"てしまうと、`scorers`を使わないユーザーも新たに`NULL`を挿入して"
"`pgroonga_full_text_search_condition`型の値を作らなければなりません。"

msgid ""
"However, installing `pgroonga_condition()` function to make new "
"`pgroonga_condition` type value let a new attribution to be added while "
"keeping backward compatibility.\n"
"It is because `pgroonga_condition()` function absorb incompatibility."
msgstr ""
"しかし、`pgroonga_condition`型の値を作るための便利関数`pgroonga_condition()`"
"関数を導入することにより後方互換性を維持したまま`pgroonga_condition`型に新し"
"い属性を追加できます。\n"
"`pgroonga_condition()`関数が非互換を吸収してくれるからです。"

msgid ""
"`pgroonga_condition()` function let current writing style when a new "
"attribute value is added because the function can leave out unnecessary "
"attribution value as following sample.\n"
"( In the following sample, `weights`、`scorers`、`schema_name`、"
"`column_name` are left out. The details of attribute values would be noted "
"in next \"Sytax\". Here, point is that possibility of leaving out "
"unnecessary attribute values.)"
msgstr ""
"次のように、`pgroonga_condition()`関数は不要な属性値を省略できるため、新たに"
"属性値が追加されても既存の書き方を維持できます。\n"
"(次の例では、`weights`、`scorers`、`schema_name`、`column_name`を省略していま"
"す。属性値の詳細については、後述の「構文」で記載します。ここでは、不要な属性"
"値が省略できることに注目してください。)"

msgid ""
"```\n"
"title &@~ pgroonga_condition('keyword', index_name => 'index_name')\n"
"```"
msgstr ""

msgid ""
"Please note that while using `pgroonga_condition()` functionm you can "
"leaving out attribute values instead you need to describe comment like key "
"word argument such as \"index_name => 'index name'\"."
msgstr ""
"`pgroonga_condition()`関数では、上のように属性値を省略できますが、代わりに、"
"「index_name => 'index name'」のようにキーワード引数のような記載が必要になる"
"ことに注意してください。"

msgid ""
"In the above sample, there are mix of attribute values which is like key "
"word argument or not.\n"
"How to separate writing is going to be explained in next ## Syntax.\n"
"The point here is there is need of different writing from the current."
msgstr ""
"上の例では、キーワード引数のような書き方をしている属性値とそうでない属性値が"
"あります。\n"
"どのように書き分けるかについては、後述の「構文」で記載します。\n"
"ここでは、従来とは異なる書き方が必要になることがあるという点に注目してくださ"
"い。"

msgid "## Syntax"
msgstr "## 構文"

msgid "Here is the syntax of this function:"
msgstr "この関数の構文は次の通りです。"

msgid ""
"```\n"
"pgroonga_condition pgroonga_condition(query,\n"
"                                      weights,\n"
"                                      scorers,\n"
"                                      schema_name,\n"
"                                      index_name,\n"
"                                      column_name)\n"
"```"
msgstr ""

msgid "`query`は検索キーワードです。`text`型です。"
msgstr ""

msgid "`weights`はそれぞれの値の重要度です。`int[]`型です。"
msgstr ""

msgid "`scorers`はそれぞれの値のスコアーを計算する処理です。`text[]`型です。"
msgstr ""

msgid ""
"`schema_name`はシーケンシャルサーチ実行時に参照するインデックスが属するスキー"
"マです。`text`型です。"
msgstr ""

msgid ""
"`index_name`はシーケンシャルサーチ実行時に参照するインデックスです。`text`型"
"です。"
msgstr ""

msgid ""
"`column_name`はシーケンシャルサーチ実行時に参照するインデックスが紐付けられて"
"いる属性です。`text`型です。"
msgstr ""

msgid ""
"`pgroonga_condition()`の引数はすべて省略可能です。そのため、[「`引数名 => 値"
"`」][sql-syntax-calling-funcs-named]という名前付き表記を使うことで特定の引数"
"だけ指定することができます。たとえば、`index_name`だけ指定する場合は"
"`pgroonga_condition(index_name => 'index1')`となります。\n"
"ただ、一般的なユースケースでは次の3種類の書き方を覚えておけば十分です。"
msgstr ""

msgid ""
"```\n"
"title &@~ pgroonga_condition('query', index_name => 'pgroonga_index')\n"
"title &@~ pgroonga_condition('query', ARRAY[weight1, weight2, ...])\n"
"title &@~ pgroonga_condition('query', ARRAY[weight1, weight2, ...], "
"index_name => 'pgroonga_index')\n"
"```"
msgstr ""

msgid ""
"上の例以外の使い方をする場合のために、「`引数名 => 値`」で記述する必要がある"
"引数とそうでない引数の違いを説明します。\n"
"例えば、次は引数`weights`、`scorers`、`schema_name`、`column_name`を省略して"
"います。"
msgstr ""

msgid ""
"```\n"
"title &@~ pgroonga_condition('query', index_name => 'pgroonga_index')\n"
"```"
msgstr ""

msgid ""
"引数`weights`と`scorers`と`schema_name`を省略したことで、引数`index_name`の指"
"定は第2引数の位置にありますが、\n"
"関数のシグネチャーでは`index_name`は第5引数なので、このケースでは、"
"`index_name`は関数のシグネチャーと位置が異なる引数となります。\n"
"一方、第1引数にある`query`は「`引数名 => 値`」という表記ではないので、関数の"
"シグネチャーと位置が同じ引数となります。"
msgstr ""

msgid ""
"つまり、関数のシグネチャーと同じ位置にある、`query`は、「`引数名 => 値`」の形"
"で書く必要はなく、値をそのまま記述できますが、\n"
"関数のシグネチャーと違う位置にある、`index_name`は、「`引数名 => 値`」の形で"
"書く必要があります。"
msgstr ""

msgid "## Usage"
msgstr "## 使い方"

msgid "Here are sample schema and data:"
msgstr "サンプルスキーマとデータは次の通りです。"

msgid ""
"```sql\n"
"CREATE TABLE memos (\n"
"  id integer,\n"
"  title text,\n"
"  content text\n"
");"
msgstr ""

msgid ""
"CREATE INDEX pgroonga_memos_index\n"
"          ON memos\n"
"       USING pgroonga (title)\n"
"        WITH (normalizers='NormalizerNFKC150(\"unify_katakana_v_sounds\", "
"true)');"
msgstr ""

msgid ""
"INSERT INTO memos VALUES (1, 'ヴァイオリン', E'Let\\'s play violin!');\n"
"```"
msgstr ""

msgid ""
"インデックスサーチ時はインデックスに指定したオプションで検索結果をカスタマイ"
"ズできます。\n"
"上のサンプルでは、`normalizers='...'`の部分でオプションを指定しています。\n"
"一方、インデックスサーチではなくシーケンシャルサーチが実行されると、PGroonga"
"のインデックスに指定されているオプションを参照できません。\n"
"シーケンシャルサーチ時はどのインデックスを参照すればよいかという情報がないか"
"らです。"
msgstr ""

msgid ""
"そのため、シーケンシャルサーチ実行時と、インデックスサーチ実行時で検索結果が"
"異なる可能性があります。\n"
"この問題を回避するためにシーケンシャルサーチ時に参照するインデックスを明示的"
"に指定できます。`index_name => '...'`がそのための引数です。"
msgstr ""

msgid ""
"次の例は、シーケンシャルサーチが実行されていますが、「バイオリン」で「ヴァイ"
"オリン」がヒットしていることが確認できます。\n"
"シーケンシャルサーチ実行時でもインデックスに設定されている"
"`NormalizerNFKC150(\"unify_katakana_v_sounds\", true)`が参照できていることが"
"わかります。"
msgstr ""

msgid ""
"```sql\n"
"EXPLAIN ANALYZE\n"
"SELECT *\n"
"  FROM memos\n"
" WHERE title &@~ pgroonga_condition('バイオリン',\n"
"                                    index_name => 'pgroonga_memos_index');\n"
"                                           QUERY "
"PLAN                                            \n"
"-------------------------------------------------------------------------------------------------\n"
" Seq Scan on memos  (cost=0.00..2.52 rows=1 width=100) (actual "
"time=2.230..2.406 rows=2 loops=1)\n"
"   Filter: (title &@~ '(バイオリン,,,,pgroonga_memos_index,)'::"
"pgroonga_condition)\n"
"   Rows Removed by Filter: 1\n"
" Planning Time: 2.222 ms\n"
" Execution Time: 2.525 ms\n"
"(5 rows)"
msgstr ""

msgid ""
"SELECT *\n"
"  FROM memos\n"
" WHERE title &@~ pgroonga_condition('バイオリン',\n"
"                                    index_name => 'pgroonga_memos_index');\n"
" id |    title     |      content       | tag  \n"
"----+--------------+--------------------+------\n"
"  2 | ヴァイオリン | content2           | tag2\n"
"  1 | ヴァイオリン | Let's play violin! | \n"
"(2 rows)\n"
"```"
msgstr ""

msgid "## See also"
msgstr "## 参考"

msgid ""
"* [postgres_fdw][postgres-fdw]\n"
"* [normalizers_mapping][normalizers-mapping]\n"
"* [名前付け表記][sql-syntax-calling-funcs-named]"
msgstr ""

msgid ""
"[postgres-fdw]:{{ site.postgresql_doc_base_url.en }}/postgres-fdw.html\n"
"[normalizers-mapping]:../create-index-using-pgroonga.html#custom-normalizer\n"
"[sql-syntax-calling-funcs-named]:{{ site.postgresql_doc_base_url.en }}/sql-"
"syntax-calling-funcs.html#SQL-SYNTAX-CALLING-FUNCS-NAMED"
msgstr ""
