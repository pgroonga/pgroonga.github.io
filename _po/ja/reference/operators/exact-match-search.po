msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"title: \"&= operator\"\n"
"upper_level: ../\n"
"---"
msgstr ""
"---\n"
"title: \"&= 演算子\"\n"
"upper_level: ../\n"
"---"

msgid "# `&=` operator"
msgstr "# `&=` 演算子"

msgid "Since 2.4.6."
msgstr "2.4.6 で追加"

msgid "## Summary"
msgstr "## 概要"

msgid "`&=` operator performs exact match search."
msgstr "`&=` 演算子は完全一致検索を実行します。"

msgid "## Syntax"
msgstr "## 構文"

msgid ""
"```sql\n"
"column &= keyword\n"
"column &= (keyword, NULL, index_name)::pgroonga_full_text_search_condition\n"
"```"
msgstr ""

msgid "The first syntax does not use normally."
msgstr "1つ目の構文は通常使用しません。"

msgid ""
"The second syntax is for using custom normalizer even if PGroonga's index is u"
"sed or not."
msgstr "2つ目の構文はPGroongaのインデックスが使用されるかどうかに関わらず、カスタマイズしたノーマライザーを使用するためのものです。"

msgid "Here is the description of the first signature."
msgstr "以下は1つ目の使い方の説明です。"

msgid ""
"```sql\n"
"column &= keyword\n"
"```"
msgstr ""

msgid "`column` is a column to be searched. It's `text` type or `varchar` type."
msgstr "`column`は検索対象のカラムです。型は`text`型か`varchar`型です。"

msgid "`keyword` is a keyword for exact match search . It's `text` type."
msgstr "`keyword` は完全一致検索で使うキーワードです。 `text` 型です。"

msgid "The operator returns `true` when the `column` exact match with `keyword`."
msgstr "`column` と `keyword` が完全に一致した時に `true` を返します。"

msgid "Here is the description of the second signature."
msgstr "以下は2つ目の使い方の説明です。"

msgid ""
"```sql\n"
"column &= (keyword, NULL, index_name)::pgroonga_full_text_search_condition\n"
"```"
msgstr ""

msgid ""
"The second argument is set only NULL. Because this syntax is not for optimizin"
"g search score."
msgstr "2つ目の引数はNULLのみ設定されます。この構文は検索スコアーの最適化をするためのものでは無いためです。"

msgid ""
"`index_name` is an index name of the corresponding PGroonga index. It's `text`"
" type."
msgstr "`index_name`は対応するPGroongaのインデックス名です。`text`型です。"

msgid ""
"It's for using the same search options specified in PGroonga index in sequenti"
"al search."
msgstr "これはシーケンシャルサーチのときにもPGroongaのインデックスに指定した検索オプションを使えるようにするために使われます。"

msgid "## Operator classes"
msgstr "## 演算子クラス"

msgid "We need to specify one of the following operator classes to use this operator:"
msgstr "この演算子を使うには次のどれかの演算子クラスを指定する必要があります。"

msgid "  * `pgroonga_text_term_search_ops_v2`: For `text`"
msgstr "  * `pgroonga_text_term_search_ops_v2`：`text`用"

msgid "  * `pgroonga_varchar_term_search_ops_v2`: For `varchar`"
msgstr "  * `pgroonga_varchar_term_search_ops_v2`：`varchar`用"

msgid "## Usage"
msgstr "## 使い方"

msgid ""
"If PostgreSQL use PGroonga's index as below, `&=` operator can use custom norm"
"alizer."
msgstr "以下のようにPostgreSQLがPGroongaのインデックスを使う場合は、 `&=` 演算子はカスタマイズしたノーマライザーを使えます。"

msgid ""
"Therefore, PostgreSQL returns 2 records(Groonga and groonga) by the search key"
"word like `gr-oonga` in the following example."
msgstr ""
"したがって、 以下の例のようにPostgreSQLは `gr-oonga` のような検索キーワードで2つのレコード(Groonga と groonga)を返"
"します。"

msgid ""
"```sql\n"
"CREATE TABLE tags (\n"
"  id int,\n"
"  name text\n"
");"
msgstr ""

msgid ""
"CREATE INDEX pgrn_index ON tags\n"
"  USING pgroonga (name pgroonga_text_term_search_ops_v2)\n"
"  WITH (normalizers='NormalizerNFKC150(\"remove_symbol\", true)');"
msgstr ""

msgid ""
"INSERT INTO tags VALUES (1, 'PostgreSQL');\n"
"INSERT INTO tags VALUES (2, 'Groonga');\n"
"INSERT INTO tags VALUES (3, 'groonga');\n"
"INSERT INTO tags VALUES (4, 'PGroonga');"
msgstr ""

msgid ""
"EXPLAIN (COSTS OFF)\n"
"SELECT name\n"
"  FROM tags\n"
" WHERE name &= 'gr-oonga';\n"
"QUERY PLAN\n"
"Bitmap Heap Scan on tags\n"
"   Recheck Cond: (name &= 'gr-oonga'::text)\n"
"   ->  Bitmap Index Scan on pgrn_index\n"
"         Index Cond: (name &= 'gr-oonga'::text)\n"
"(4 rows)"
msgstr ""

msgid ""
"SELECT name\n"
"  FROM tags\n"
" WHERE name &= 'gr-oonga';\n"
"--    name    \n"
"-- -----------\n"
"--  PGroonga\n"
"--  pglogical\n"
"-- (2 rows)\n"
"```"
msgstr ""

msgid ""
"However, if PostgreSQL does not use PGroonga's index, `&=` operator can not us"
"e custom normalizer."
msgstr "しかし、PostgreSQLがPGroongaのインデックスを使わない場合は、 `&=` 演算子はカスタマイズしたノーマライザーを使えません。"

msgid ""
"Therefore, PostgreSQL returns no record by the search keyword like `gr-oonga` "
"in the following example."
msgstr "したがって、 以下の例のようにPostgreSQLは `gr-oonga` のような検索キーワードではレコードを返しません。"

msgid ""
"SET enable_seqscan = on;\n"
"SET enable_indexscan = off;\n"
"SET enable_bitmapscan = off;"
msgstr ""

msgid ""
"EXPLAIN (COSTS OFF)\n"
"SELECT name\n"
"  FROM tags\n"
" WHERE name &= 'gr-oonga';\n"
"QUERY PLAN\n"
"Seq Scan on tags\n"
"  Filter: (name &= 'gr-oonga'::text)\n"
"(2 rows)"
msgstr ""

msgid ""
"SELECT name\n"
"  FROM tags\n"
" WHERE name &= 'gr-oonga';\n"
" name \n"
"------\n"
"(0 rows)\n"
"```"
msgstr ""

msgid ""
"On the other hand, if we use the second syntax, we can exact match search with"
" custom normalizer even if PGroonga's index is not used."
msgstr "一方、2つ目の構文を使う場合は、PGroongaのインデックスを使うかどうかに関わらず、完全一致検索でカスタマイズしたノーマライザーを使えます。"

msgid ""
"CREATE INDEX pgrn_index ON tags\n"
"  USING pgroonga (name pgroonga_text_term_search_ops_v2);"
msgstr ""

msgid ""
"EXPLAIN (COSTS OFF)\n"
"SELECT name\n"
"  FROM tags\n"
" WHERE name &= ('groonga', NULL, 'pgrn_index')::pgroonga_full_text_search_cond"
"ition\n"
" ORDER BY id;\n"
"QUERY PLAN\n"
"Sort\n"
"  Sort Key: id\n"
"  ->  Seq Scan on tags\n"
"        Filter: (name &= '(groonga,,pgrn_index)'::pgroonga_full_text_search_co"
"ndition)\n"
"(4 rows)"
msgstr ""

msgid ""
"SELECT name\n"
"  FROM tags\n"
" WHERE name &= ('groonga', NULL, 'pgrn_index')::pgroonga_full_text_search_cond"
"ition\n"
" ORDER BY id;\n"
"  name   \n"
"---------\n"
" Groonga\n"
" groonga\n"
"(2 rows)\n"
"```"
msgstr ""
