msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2023-08-13 09:53+0900\n"

msgid ""
"---\n"
"title: \"&^ operator\"\n"
"upper_level: ../\n"
"---"
msgstr ""
"---\n"
"title: \"&^演算子\"\n"
"upper_level: ../\n"
"---"

msgid "# `&^` operator"
msgstr "# `&^`演算子"

msgid "Since 1.2.1."
msgstr "1.2.1で追加。"

msgid "## Summary"
msgstr "## 概要"

msgid ""
"`&^>` operator for `text[]` is deprecated since 1.2.1. Use `&^` operator "
"instead."
msgstr ""
"1.2.1から`text[]`用の`&^>`演算子は非推奨になりました。代わりに`&^`演算子を"
"使ってください。"

msgid "`&^` operator performs prefix search."
msgstr "`&^`演算子は前方一致検索を実行します。"

msgid "Prefix search is useful for implementing input completion."
msgstr "前方一致検索は入力補完機能を実現する場合に便利です。"

msgid "## Syntax"
msgstr "## 構文"

msgid ""
"```sql\n"
"column &^ prefix\n"
"column &^ (prefix, NULL, index_name)::pgroonga_full_text_search_condition\n"
"column &^ pgroonga_condition(prefix, index_name => 'index_name')\n"
"```"
msgstr ""

msgid "The first signature is enough for most cases."
msgstr "多くの場合は1つ目の使い方で十分です。"

msgid ""
"The second signature is for using custom normalizer even if PGroonga's index "
"is used or not.\n"
"The second signature is available since 2.4.6."
msgstr ""
"2つ目の使い方はPGroongaのインデックスが使用されるかどうかに関わらず、カスタマ"
"イズしたノーマライザーを使用するためのものです。\n"
"2つ目の使い方は、2.4.6から使えます。"

msgid ""
"The third signature has the same meaning as the second signature.\n"
"You should use this signature in 3.1.6 and above.\n"
"See [`pgroonga_condition` function][condition] for details."
msgstr ""
"3つ目の使い方は2つ目と同じ意味です。3.1.6以降は3つ目の構文を使ってください。"
"詳しくは[`pgroonga_condition`関数][condition]をご覧ください。"

msgid "Here is the description of the first signature."
msgstr "以下は1つ目の使い方の説明です。"

msgid ""
"```sql\n"
"column &^ prefix\n"
"```"
msgstr ""

msgid "`column` is a column to be searched. It's `text` type or `text[]` type."
msgstr "`column`は検索対象のカラムです。型は`text`型か`text[]`型です。"

msgid "`prefix` is a prefix to be found. It's `text` type."
msgstr "`prefix`は含まれているべきプレフィックスです。`text`型です。"

msgid ""
"The operator returns `true` when the `column` value starts with `prefix`."
msgstr "`column`の値が`prefix`から始まっていれば`true`を返します。"

msgid "Here is the description of the second signature."
msgstr "以下は2つ目の使い方の説明です。"

msgid ""
"```sql\n"
"column &^ (prefix, NULL, index_name)::pgroonga_full_text_search_condition\n"
"```"
msgstr ""

msgid ""
"`column` is a column to be searched. It's `text` type or `varchar` type."
msgstr "`column`は検索対象のカラムです。型は`text`型か`varchar`型です。"

msgid ""
"The second argument is set only NULL. Because this syntax is not for "
"optimizing search score."
msgstr ""
"2つ目の引数はNULLのみ設定されます。この構文は検索スコアーの最適化をするための"
"ものでは無いためです。"

msgid ""
"`index_name` is an index name of the corresponding PGroonga index. It's "
"`text` type."
msgstr "`index_name`は対応するPGroongaのインデックス名です。`text`型です。"

msgid ""
"It's for using the same search options specified in PGroonga index in "
"sequential search."
msgstr ""
"これはシーケンシャルサーチのときにもPGroongaのインデックスに指定した検索オプ"
"ションを使えるようにするために使われます。"

msgid "## Operator classes"
msgstr "## 演算子クラス"

msgid ""
"You need to specify one of the following operator classes to use this "
"operator:"
msgstr "この演算子を使うには次のどれかの演算子クラスを指定する必要があります。"

msgid "  * `pgroonga_text_term_search_ops_v2`: For `text`"
msgstr "  * `pgroonga_text_term_search_ops_v2`：`text`用"

msgid "  * `pgroonga_text_array_term_search_ops_v2`: For `text[]`"
msgstr "  * `pgroonga_text_array_term_search_ops_v2`：`text[]`用"

msgid "  * `pgroonga_varchar_term_search_ops_v2`: For `varchar`"
msgstr "  * `pgroonga_varchar_term_search_ops_v2`：`varchar`用"

msgid "## Usage"
msgstr "## 使い方"

msgid "Here are sample schema and data for examples:"
msgstr "例に使うサンプルスキーマとデータは次の通りです。"

msgid ""
"```sql\n"
"CREATE TABLE tags (\n"
"  name text PRIMARY KEY\n"
");"
msgstr ""

msgid ""
"CREATE INDEX pgroonga_tag_name_index ON tags\n"
"  USING pgroonga (name pgroonga_text_term_search_ops_v2);\n"
"```"
msgstr ""

msgid ""
"```sql\n"
"INSERT INTO tags VALUES ('PostgreSQL');\n"
"INSERT INTO tags VALUES ('Groonga');\n"
"INSERT INTO tags VALUES ('PGroonga');\n"
"INSERT INTO tags VALUES ('pglogical');\n"
"```"
msgstr ""

msgid "You can perform prefix search with prefix by `&^` operator:"
msgstr "`&^`演算子を使うと指定したプレフィックスで前方一致検索を実行できます。"

msgid ""
"```sql\n"
"SELECT * FROM tags WHERE name &^ 'pg';\n"
"--    name    \n"
"-- -----------\n"
"--  PGroonga\n"
"--  pglogical\n"
"-- (2 rows)\n"
"```"
msgstr ""

msgid "You can use custom normalizer in prefix search as below."
msgstr "以下のように前方一致検索でカスタマイズしたノーマライザーを使えます。"

msgid ""
"```sql\n"
"CREATE TABLE tags (\n"
"  name text\n"
");"
msgstr ""

msgid ""
"CREATE INDEX pgroonga_tag_name_index ON tags\n"
"  USING pgroonga (name pgroonga_text_term_search_ops_v2)\n"
"  WITH (normalizers='NormalizerNFKC150(\"remove_symbol\", true)');\n"
"```"
msgstr ""

msgid ""
"You can prefix search with custom normalizer even if PGroonga's index is not "
"used."
msgstr ""
"PGroongaのインデックスが使用されるかどうかに関わらず、カスタマイズしたノーマ"
"ライザーで前方一致検索ができます。"

msgid ""
"```sql\n"
"SET enable_seqscan = on;\n"
"SET enable_indexscan = off;\n"
"SET enable_bitmapscan = off;"
msgstr ""

msgid ""
"EXPLAIN (COSTS OFF)\n"
"SELECT name\n"
"  FROM tags\n"
" WHERE name &^ ('-p_G', NULL, 'pgroonga_tag_name_index')::"
"pgroonga_full_text_search_condition;\n"
"QUERY PLAN\n"
"Seq Scan on tags\n"
"  Filter: (name &^ '(-p_G,,pgroonga_tag_name_index)'::"
"pgroonga_full_text_search_condition)\n"
"(2 rows)"
msgstr ""

msgid ""
"SELECT name\n"
"  FROM tags\n"
" WHERE name &^ ('-p_G', NULL, 'pgroonga_tag_name_index')::"
"pgroonga_full_text_search_condition;\n"
"   name    \n"
"-----------\n"
" PGroonga\n"
" pglogical\n"
"(2 rows)\n"
"```"
msgstr ""

msgid ""
"The same query with [`pgroonga_condition` function][condition] is as follows."
msgstr ""
"同じクエリを[`pgroonga_condition`関数][condition]を使うと以下の通りです。"

msgid ""
"```sql\n"
"EXPLAIN (COSTS OFF)\n"
"SELECT name\n"
"  FROM tags\n"
" WHERE name &^ pgroonga_condition('-p_G', index_name => "
"'pgroonga_tag_name_index');\n"
"                                  QUERY "
"PLAN                                   \n"
"-------------------------------------------------------------------------------\n"
" Seq Scan on tags\n"
"   Filter: (name &^ '(-p_G,,,,pgroonga_tag_name_index,,)'::"
"pgroonga_condition)\n"
"(2 rows)"
msgstr ""

msgid ""
"SELECT name\n"
"  FROM tags\n"
" WHERE name &^ pgroonga_condition('-p_G', index_name => "
"'pgroonga_tag_name_index');\n"
"   name\n"
"-----------\n"
" PGroonga\n"
" pglogical\n"
"(2 rows)\n"
"```"
msgstr ""

msgid "## See also"
msgstr "## 参考"

msgid "  * [`&^~` operator][prefix-rk-search-v2]: Prefix RK search"
msgstr "  * [`&^~`演算子][prefix-rk-search-v2]：前方一致RK検索"

msgid ""
"  * [`&^|` operator][prefix-search-in-v2]: Prefix search by an array of "
"prefixes"
msgstr ""
"  * [`&^|`演算子][prefix-search-in-v2]：プレフィックスの配列での前方一致検索"

msgid ""
"  * [`!&^|` operator][not-prefix-search-in-v2]: NOT prefix search by an "
"array of prefixes"
msgstr ""
"  * [`!&^|`演算子][not-prefix-search-in-v2]：プレフィックスの配列での否定前方"
"一致検索"

msgid ""
"  * [`&^~|` operator][prefix-rk-search-in-v2]: Prefix RK search by an array "
"of prefixes"
msgstr ""
"  * [`&^~|`演算子][prefix-rk-search-in-v2]：プレフィックスの配列での前方一致"
"RK検索"

msgid "  * [`pgroonga_condition` function][condition]"
msgstr "  * [`pgroonga_condition`関数][condition]"

msgid "[prefix-rk-search-v2]:prefix-rk-search-v2.html"
msgstr ""

msgid "[prefix-search-in-v2]:prefix-search-in-v2.html"
msgstr ""

msgid "[not-prefix-search-in-v2]:not-prefix-search-in-v2.html"
msgstr ""

msgid "[prefix-rk-search-in-v2]:prefix-rk-search-in-v2.html"
msgstr ""

msgid "[condition]:../functions/pgroonga-condition.html"
msgstr ""
